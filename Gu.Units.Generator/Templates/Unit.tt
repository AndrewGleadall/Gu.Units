<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="$(TargetPath)" #>
<#@ import namespace="Gu.Units.Generator" #>
<#@ parameter name="UnitMetaData" type="Gu.Units.Generator.IUnit" #>
<#@ output extension=".txt" #>
<#
// Template used by UnitGenerator.tt
IUnit unit;
if(UnitMetaData != null)
{
    unit = UnitMetaData;
}
else
{
    unit = new SiUnit("Gu.Units", "Metres", "m")
                    {
                        Quantity = new Quantity("Gu.Units", "Length", null)
                    };
    unit.SubUnits.Add(new SubUnit("Gu.Units", "Centimetres", "cm", 1E-2));
    unit.SubUnits.Add(new SubUnit("Gu.Units", "Millimetres", "mm", 1E-3));
}
#>
namespace <#= unit.Namespace #>
{
    using System;
    /// <summary>
    /// A type for the unit <see cref="T:<#= unit.Namespace #>.<#= unit.Quantity.ClassName #>Unit"/>.
	/// Contains conversion logic.
    /// </summary>
    [Serializable]
    public struct <#= unit.Quantity.ClassName #>Unit : IUnit
    {
        /// <summary>
        /// The <see cref="T:<#= unit.Namespace #>.<#= unit.ClassName #>"/> unit
        /// Contains coonversion logic to from and formatting.
        /// </summary>
        public static readonly <#= unit.Quantity.ClassName #>Unit <#= unit.ClassName #> = new <#= unit.Quantity.ClassName #>Unit(1.0, "<#= unit.Symbol #>");
<#
		    if(unit.IsSymbolNameValid)
            {
		    #>
        /// <summary>
        /// The <see cref="T:<#= unit.Namespace #>.<#= unit.ClassName #>"/> unit
        /// Contains coonversion logic to from and formatting.
        /// </summary>
		public static readonly <#= unit.Quantity.ClassName #>Unit <#= unit.Symbol #> = <#= unit.ClassName #>;
<#
            }
            #><#
		foreach(var su in unit.SubUnits)
        {
		#>

        /// <summary>
        /// The <see cref="T:<#= unit.Namespace #>.<#= su.ClassName #>"/> unit
        /// Contains coonversion logic to from and formatting.
        /// </summary>
		public static readonly <#= unit.Quantity.ClassName #>Unit <#= su.ClassName #> = new <#= unit.Quantity.ClassName #>Unit(<#= su.ConversionFactor #>, "<#= su.Symbol #>");
<#
		    if(su.IsSymbolNameValid)
            {
		    #>
        /// <summary>
        /// The <see cref="T:<#= unit.Namespace #>.<#= su.ClassName #>"/> unit
        /// Contains coonversion logic to from and formatting.
        /// </summary>
		public static readonly <#= unit.Quantity.ClassName #>Unit <#= su.Symbol #> = <#= su.ClassName #>;
<#
            }
            #><#
        }
        #>

        private readonly double _conversionFactor;
        private readonly string _symbol;

        public <#= unit.Quantity.ClassName #>Unit(double conversionFactor, string symbol)
        {
            _conversionFactor = conversionFactor;
            _symbol = symbol;
        }

		/// <summary>
        /// The symbol for <see cref="T:<#= unit.Namespace #>.<#= unit.ClassName #>"/>.
        /// </summary>
        public string Symbol
        {
            get
            {
                return _symbol;
            }
        }

        public static <#= unit.Quantity.ClassName #> operator *(double left, <#= unit.Quantity.ClassName #>Unit right)
        {
            return <#= unit.Quantity.ClassName #>.From(left, right);
        }

        /// <summary>
        /// Converts a value to <see cref="T:<#= unit.Namespace #>.<#= unit.ClassName #>"/>.
        /// </summary>
        /// <param name="value"></param>
        /// <returns>The converted value</returns>
        public double <#= Gu.Units.Generator.Methods.ToSiUnit #>(double value)
        {
            return _conversionFactor * value;
        }

        /// <summary>
        /// Converts a value from <#= unit.ClassName #>.
        /// </summary>
        /// <param name="value">The value in <#= unit.ClassName #></param>
        /// <returns>The converted value</returns>
        public double <#= Gu.Units.Generator.Methods.FromSiUnit #>(double value)
        {
            return value / _conversionFactor;
        }

        public override string ToString()
        {
            return string.Format("1{0} == {1}{2}", _symbol, this.<#= Gu.Units.Generator.Methods.ToSiUnit #>(1), <#= unit.ClassName #>.Symbol);
        }
    }
}
<#@ template debug="true" hostspecific="false" language="C#" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ assembly name="$(TargetPath)" #>
<#@ import namespace="Gu.Units.Generator" #>
<#@ parameter name="UnitMetaData" type="Gu.Units.Generator.IUnit" #>
<#@ output extension=".txt" #>
<#
// Template used by UnitGenerator.tt
IUnit unit;
if(UnitMetaData != null)
{
    unit = UnitMetaData;
}
else
{
    unit = new SiUnit("Metres", "m")
                    {
                        QuantityName =  "Length"
                    };
    unit.Conversions.Add(new Conversion("Centimetres", "cm"));
    unit.Conversions.Add(new Conversion("Millimetres", "mm"));
}
#>
namespace <#= Settings.Namespace #>
{
    using System;
    /// <summary>
    /// A type for the unit <see cref="T:<#= Settings.Namespace #>.<#= unit.QuantityName #>Unit"/>.
	/// Contains conversion logic.
    /// </summary>
    [Serializable]
    public struct <#= unit.QuantityName #>Unit : IUnit, IUnit<<#= unit.QuantityName #>>, IEquatable<<#= unit.QuantityName #>Unit>
    {
        /// <summary>
        /// The <see cref="T:<#= Settings.Namespace #>.<#= unit.ClassName #>"/> unit
        /// Contains coonversion logic to from and formatting.
        /// </summary>
<#
	if (unit.AnyOffsetConversion)
	{
	    #>
        public static readonly <#= unit.QuantityName #>Unit <#= unit.ClassName #> = new <#= unit.QuantityName #>Unit(1.0, 0, "<#= unit.Symbol #>");
<#
	}
	else
	{
	    #>
        public static readonly <#= unit.QuantityName #>Unit <#= unit.ClassName #> = new <#= unit.QuantityName #>Unit(1.0, "<#= unit.Symbol #>");
<#
	}
        #>
<#
		    if(unit.IsSymbolNameValid)
            {
		    #>
        /// <summary>
        /// The <see cref="T:<#= Settings.Namespace #>.<#= unit.ClassName #>"/> unit
        /// Contains conversion logic to from and formatting.
        /// </summary>
		public static readonly <#= unit.QuantityName #>Unit <#= unit.Symbol #> = <#= unit.ClassName #>;
<#
            }
            #><#
		foreach(var su in unit.Conversions)
        {
		#>

        /// <summary>
        /// The <see cref="T:<#= Settings.Namespace #>.<#= su.ClassName #>"/> unit
        /// Contains conversion logic to from and formatting.
        /// </summary>
<#
	if (unit.AnyOffsetConversion)
	{
	    #>
		public static readonly <#= unit.QuantityName #>Unit <#= su.ClassName #> = new <#= unit.QuantityName #>Unit(<#= su.Formula.ConversionFactor #>, <#= su.Formula.Offset #>, "<#= su.Symbol #>");
<#
	}
	else
	{
	    #>
		public static readonly <#= unit.QuantityName #>Unit <#= su.ClassName #> = new <#= unit.QuantityName #>Unit(<#= su.Formula.ConversionFactor.ToString("R", CultureInfo.InvariantCulture) #>, "<#= su.Symbol #>");
<#
	}
        #><#
		    if(su.IsSymbolNameValid)
            {
		    #>
        /// <summary>
        /// The <see cref="T:<#= Settings.Namespace #>.<#= su.ClassName #>"/> unit
        /// Contains coonversion logic to from and formatting.
        /// </summary>
		public static readonly <#= unit.QuantityName #>Unit <#= su.Symbol #> = <#= su.ClassName #>;
<#
            }
            #><#
        }
        #>

		private readonly double conversionFactor;
<#
	if(unit.AnyOffsetConversion)
    {
	#>
        private readonly double offset;
<#
    }
        #>
        private readonly string symbol;

<#
	if (unit.AnyOffsetConversion)
	{
	    #>
        public <#= unit.QuantityName #>Unit(double conversionFactor, double offset, string symbol)
<#
	}
	else
	{
	    #>
        public <#= unit.QuantityName #>Unit(double conversionFactor, string symbol)
<#
	}
        #>
        {
            this.conversionFactor = conversionFactor;
<#
	if(unit.AnyOffsetConversion)
    {
	#>
        this.offset = offset;
<#
    }
        #>
            this.symbol = symbol;
        }

		/// <summary>
        /// The symbol for <see cref="T:<#= Settings.Namespace #>.<#= unit.ClassName #>"/>.
        /// </summary>
        public string Symbol
        {
            get
            {
                return this.symbol;
            }
        }

        public static <#= unit.QuantityName #> operator *(double left, <#= unit.QuantityName #>Unit right)
        {
            return <#= unit.QuantityName #>.From(left, right);
        }

	    public static bool operator ==(<#= unit.QuantityName #>Unit left, <#= unit.QuantityName #>Unit right)
        {
            return left.Equals(right);
        }

        public static bool operator !=(<#= unit.QuantityName #>Unit left, <#= unit.QuantityName #>Unit right)
        {
            return !left.Equals(right);
        }

        /// <summary>
        /// Converts a value to <see cref="T:<#= Settings.Namespace #>.<#= unit.ClassName #>"/>.
        /// </summary>
        /// <param name="value"></param>
        /// <returns>The converted value</returns>
        public double <#= Gu.Units.Generator.Names.ToSiUnit #>(double value)
        {
<#
	if (unit.AnyOffsetConversion)
	{
	    #>
			return (value - this.offset) /  this.conversionFactor;
<#
	}
	else
	{
	    #>
            return this.conversionFactor * value;
<#
	}
        #>
        }

        /// <summary>
        /// Converts a value from <#= unit.ClassName #>.
        /// </summary>
        /// <param name="value">The value in <#= unit.ClassName #></param>
        /// <returns>The converted value</returns>
        public double <#= Gu.Units.Generator.Names.FromSiUnit #>(double value)
        {
<#
	if (unit.AnyOffsetConversion)
	{
	    #>
			return this.conversionFactor * value + this.offset;
<#
	}
	else
	{
	    #>
            return value / this.conversionFactor;
<#
	}
        #>
        }

        /// <summary>
        /// Creates a quantity with this unit
        /// </summary>
        /// <param name="value"></param>
        /// <returns>new TTQuantity(value, this)</returns>
        public <#= unit.QuantityName #> CreateQuantity(double value)
        {
            return new <#= unit.QuantityName #>(value, this);
        }

		/// <summary>
        /// Gets the scalar value
        /// </summary>
        /// <param name="quantity"></param>
        /// <returns></returns>
        public double GetScalarValue(<#= unit.QuantityName #> quantity)
        {
            return FromSiUnit(quantity.<#= unit.ParameterName #>);
        }

        public override string ToString()
        {
            return string.Format("1{0} == {1}{2}", this.symbol, this.<#= Gu.Units.Generator.Names.ToSiUnit #>(1), <#= unit.ClassName #>.symbol);
        }

		public bool Equals(<#= unit.QuantityName #>Unit other)
        {
            return this.symbol == other.symbol;
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj))
            {
                return false;
            }

            return obj is <#= unit.QuantityName #>Unit && Equals((<#= unit.QuantityName #>Unit) obj);
        }

        public override int GetHashCode()
        {
            if (this.symbol == null)
            {
                return 0; // Needed due to default ctor
            }

            return this.symbol.GetHashCode();
        }
    }
}